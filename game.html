<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quantum Cryptography - Game</title>
    <link rel="stylesheet" href="style.css">
    <!-- Add minimal inline styles for the cipher wheel -->
    <style>
      /* Cipher wheel */
      #cipher-wheel-container { margin-top: 1rem; padding: 1rem; border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; background: rgba(255,255,255,0.05); }
      .cipher-wheel-svg { width: 260px; height: 260px; }
      .cipher-wheel-svg text { font-family: system-ui, sans-serif; font-size: 14px; dominant-baseline: middle; text-anchor: middle; fill: #fff; }
      .cipher-wheel-svg circle { fill: none; stroke: rgba(255,255,255,0.25); }
      .cipher-wheel-svg .outer-ring { /* remove CSS-based transform control; keep class for styling if needed */ }
      .cipher-wheel-svg .no-transition { /* no longer used; kept for compatibility */ }
      .cipher-wheel-meta { font-size: 0.9rem; opacity: 0.9; }
    </style>
  </head>
  <body>
    <header>
      <h1>Quantum Cryptography</h1>
      <p><em>Cryptography of the future</em></p>
      <nav>
        <a href="index.html">Home</a>
        <a href="game.html">Game</a>
        <a href="materials.html">Materials</a>
      </nav>
    </header>

    <main class="page">
      <section class="card">
        <h2>Level 1 — Caesar's Cipher</h2>
        <p>Bob's messages use a Caesar cipher. Decode the messages and type the plaintext answer.</p>

        <div id="level1">
          <div id="qbox">
            <p><strong>Encrypted message:</strong></p>
            <div id="encrypted" class="encrypted">--</div>
            <p id="hintline" style="margin-top:0.6rem; display:none;"></p>
          </div>

          <!-- Cipher wheel UI -->
          <div id="cipher-wheel-container" aria-label="Caesar cipher wheel">
            <div style="display:flex; align-items:center; gap:1rem; flex-wrap:wrap;">
              <svg id="cipher-wheel-svg" class="cipher-wheel-svg" viewBox="0 0 260 260" width="260" height="260" role="img" aria-label="Cipher wheel"></svg>
              <div style="min-width:200px;">
                <div style="font-weight:700; margin-bottom:0.4rem;">Cipher Wheel</div>
                <div class="cipher-wheel-meta" style="margin-bottom:0.6rem;">Inner: Plaintext • Outer: Ciphertext</div>
                <label for="wheel-shift">Shift: <span id="wheel-shift-label">0</span></label>
                <input id="wheel-shift" type="range" min="-25" max="25" step="1" value="0" style="width:100%; margin-top:0.4rem;">
              </div>
            </div>
          </div>

          <div id="answer-area" style="margin-top:1rem;">
            <label for="answer">Your answer</label><br>
            <input id="answer" type="text" placeholder="Type decoded message here" style="width:95%; padding:0.6rem; font-size:1rem; margin-top:0.4rem;" />
            <div style="margin-top:0.6rem; display:flex; gap:0.6rem;">
              <button id="hint" class="btn btn-outline">Show Hint</button>
              <button id="giveup" class="btn btn-outline">Give up</button>
              <button id="submit" class="btn">Submit</button>
              <button id="next" class="btn btn-outline" style="display:none;">Next</button>
            </div>
          </div>

          <div id="feedback" style="margin-top:1rem; font-weight:700;"></div>
          <div id="explanation" style="margin-top:0.6rem; color:#d0d8ff;"></div>
          
          <!-- Inline confirmation dialog for Give up -->
          <div id="confirm-giveup" style="display:none; margin-top:1rem; padding:1rem; background:rgba(255,179,71,0.15); border:2px solid #ffb347; border-radius:8px;">
            <p style="margin:0 0 0.8rem 0; color:#ffb347; font-weight:700;">Are you sure you want to give up and see the answer?</p>
            <div style="display:flex; gap:0.6rem;">
              <button id="confirm-yes" class="btn">Yes, give up</button>
              <button id="confirm-no" class="btn btn-outline">Cancel</button>
            </div>
          </div>

          <div id="score" style="margin-top:1rem; color:#ffffff;">Score: 0 / 0</div>
        </div>

        <p style="margin-top:1.4rem"><a class="btn" href="index.html">Return Home</a></p>
      </section>
    </main>

    <script>
      /*
        Edit the `questions` array below to change Level 1 content.
        Each entry: { encrypted: string, answer: string, hint: string (optional), explanation: string (optional) }
      */
      const questions = [
        { encrypted: 'GH ZKHBD', hint: '+1', answer: 'HI ALICE', explanation: "They are always chatting. I'm jealous." },
        { encrypted: 'FAI LOFAVFAE YFAOU', hint: '', answer: 'I LOVE YOU', explanation: "Oh no! Bob loves Alice. I want to steal Bob from Alice." },
        { encrypted: 'RVBOUVN', hint: '-1', answer: 'QUANTUM', explanation: "Bob is interested in quantum information. I need to learn more about it." }
      ];

      // Simple utilities for normalising answers for comparison
      function normalise(s){
        return s.toUpperCase().replace(/[^A-Z0-9 ]+/g,'').replace(/\s+/g,' ').trim();
      }

      // Wait for DOM to be ready
      document.addEventListener('DOMContentLoaded', function() {
        // UI elements
        const encryptedEl = document.getElementById('encrypted');
        const hintLine = document.getElementById('hintline');
        const answerInput = document.getElementById('answer');
        const submitBtn = document.getElementById('submit');
        const hintBtn = document.getElementById('hint');
        const giveupBtn = document.getElementById('giveup');
        const nextBtn = document.getElementById('next');
        const confirmGiveupDiv = document.getElementById('confirm-giveup');
        const confirmYesBtn = document.getElementById('confirm-yes');
        const confirmNoBtn = document.getElementById('confirm-no');
        const feedback = document.getElementById('feedback');
        const explanation = document.getElementById('explanation');
        const scoreEl = document.getElementById('score');

        // Cipher wheel elements
        const wheelSvg = document.getElementById('cipher-wheel-svg');
        const wheelShiftInput = document.getElementById('wheel-shift');
        const wheelShiftLabel = document.getElementById('wheel-shift-label');
        const SVG_NS = 'http://www.w3.org/2000/svg';
        let wheelOuterGroup = null;
        let wheelInnerGroup = null;
        const cx = 130, cy = 130, rInner = 80, rOuter = 110, stepDeg = 360 / 26;

        // Track current rotation angle to animate between states
        let currentOuterAngle = 0;
        let animFrame = null;

        function createSVGEl(name, attrs = {}) {
          const el = document.createElementNS(SVG_NS, name);
          for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
          return el;
        }

        function buildCipherWheel() {
          if (!wheelSvg) return;
          wheelSvg.innerHTML = '';

          // Background rings
          wheelSvg.appendChild(createSVGEl('circle', { cx, cy, r: rOuter + 8 }));
          wheelSvg.appendChild(createSVGEl('circle', { cx, cy, r: rInner - 8 }));

          wheelInnerGroup = createSVGEl('g', { class: 'inner-ring' });
          wheelOuterGroup = createSVGEl('g', { class: 'outer-ring' });

          for (let i = 0; i < 26; i++) {
            const letter = String.fromCharCode(65 + i);
            const angle = (i / 26) * 2 * Math.PI - Math.PI / 2;

            const xi = cx + rInner * Math.cos(angle);
            const yi = cy + rInner * Math.sin(angle);
            const xo = cx + rOuter * Math.cos(angle);
            const yo = cy + rOuter * Math.sin(angle);

            const tInner = createSVGEl('text', { x: xi, y: yi });
            tInner.textContent = letter;
            const tOuter = createSVGEl('text', { x: xo, y: yo });
            tOuter.textContent = letter;

            wheelInnerGroup.appendChild(tInner);
            wheelOuterGroup.appendChild(tOuter);
          }

          wheelSvg.appendChild(wheelInnerGroup);
          wheelSvg.appendChild(wheelOuterGroup);
          // Ensure starting transform is centered
          currentOuterAngle = 0;
          wheelOuterGroup.setAttribute('transform', `rotate(${currentOuterAngle} ${cx} ${cy})`);
        }

        function setWheelShift(s, animate = true) {
          if (!wheelOuterGroup) return;
          const targetAngle = s * stepDeg;
          wheelShiftLabel.textContent = s >= 0 ? `+${s}` : `${s}`;

          if (!animate) {
            if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
            currentOuterAngle = targetAngle;
            wheelOuterGroup.setAttribute('transform', `rotate(${currentOuterAngle} ${cx} ${cy})`);
            return;
          }

          // Smooth animation via rAF
          const startAngle = currentOuterAngle;
          const delta = targetAngle - startAngle;
          const duration = 400; // ms
          const startTime = performance.now();

          if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }

          function step(t) {
            const k = Math.min(1, (t - startTime) / duration);
            const eased = 1 - Math.pow(1 - k, 3); // easeOutCubic
            const angle = startAngle + delta * eased;
            wheelOuterGroup.setAttribute('transform', `rotate(${angle} ${cx} ${cy})`);
            if (k < 1) animFrame = requestAnimationFrame(step);
            else { currentOuterAngle = targetAngle; animFrame = null; }
          }
          animFrame = requestAnimationFrame(step);
        }

        function parseHintShift(hint) {
          if (typeof hint !== 'string' || hint.trim() === '') return null;
          const val = parseInt(hint, 10);
          return Number.isFinite(val) ? Math.max(-25, Math.min(25, val)) : null;
        }

        function updateWheelForQuestion() {
          const q = questions[idx];
          const s = parseHintShift(q.hint);
          if (s !== null) {
            wheelShiftInput.value = s;
            setWheelShift(s, true);
          } else {
            wheelShiftInput.value = 0;
            setWheelShift(0, false);
          }
        }

        wheelShiftInput.addEventListener('input', () => {
          const s = parseInt(wheelShiftInput.value, 10) || 0;
          setWheelShift(s, true);
        });

        let idx = 0; let correctCount = 0; let attemptCount = 0; let answered = false;

        // Save progress to localStorage
        function saveProgress() {
          const progress = {
            idx: idx,
            correctCount: correctCount,
            attemptCount: attemptCount,
            answered: answered
          };
          localStorage.setItem('level1Progress', JSON.stringify(progress));
        }

        // Load progress from localStorage
        function loadProgress() {
          const saved = localStorage.getItem('level1Progress');
          if(saved) {
            const progress = JSON.parse(saved);
            idx = progress.idx;
            correctCount = progress.correctCount;
            attemptCount = progress.attemptCount;
            answered = progress.answered;
          }
        }

      function loadQuestion(i){
        const q = questions[i];
        encryptedEl.textContent = q.encrypted;
        hintLine.textContent = q.hint ? `Hint: ${q.hint}` : '';
        hintLine.style.display = 'none';
        answerInput.value = '';
        feedback.textContent = '';
        explanation.textContent = '';
        confirmGiveupDiv.style.display = 'none';
        nextBtn.style.display = 'none';
        giveupBtn.disabled = false;
        submitBtn.disabled = false;
        answered = false;
        answerInput.focus();
        scoreEl.textContent = `Score: ${correctCount} / ${attemptCount}`;
        // Update wheel for this question (animate if hint present)
        updateWheelForQuestion();
      }

      function checkAnswer(){
        if(answered) return;
        const user = normalise(answerInput.value);
        const expected = normalise(questions[idx].answer);
        attemptCount++;
        if(user === expected){
          feedback.style.color = '#7ef27e';
          feedback.textContent = 'Correct!';
          correctCount++;
          explanation.textContent = questions[idx].explanation || '';
          answered = true;
          giveupBtn.disabled = true;
          submitBtn.disabled = true;
          nextBtn.style.display = '';
        } else {
          feedback.style.color = '#ff9a9a';
          feedback.textContent = 'Incorrect. Try again or give up to see the answer.';
        }
        scoreEl.textContent = `Score: ${correctCount} / ${attemptCount}`;
        saveProgress();
      }

      submitBtn.addEventListener('click', checkAnswer);
      answerInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') checkAnswer(); });

      hintBtn.addEventListener('click', ()=>{
        const q = questions[idx];
        if(q.hint){
          hintLine.style.display = hintLine.style.display === 'none' ? 'block' : 'none';
        } else {
          alert('No hint available for this question.');
        }
      });

      giveupBtn.addEventListener('click', ()=>{
        console.log('Give up clicked, answered:', answered);
        if(answered) return;
        // Show inline confirmation
        confirmGiveupDiv.style.display = 'block';
      });

      confirmYesBtn.addEventListener('click', ()=>{
        feedback.style.color = '#ffb347';
        feedback.textContent = `You gave up. The answer was: ${questions[idx].answer}`;
        explanation.textContent = questions[idx].explanation || '';
        answered = true;
        giveupBtn.disabled = true;
        submitBtn.disabled = true;
        attemptCount++;
        scoreEl.textContent = `Score: ${correctCount} / ${attemptCount}`;
        confirmGiveupDiv.style.display = 'none';
        nextBtn.style.display = '';
        saveProgress();
      });

      confirmNoBtn.addEventListener('click', ()=>{
        confirmGiveupDiv.style.display = 'none';
      });

      nextBtn.addEventListener('click', ()=>{
        idx = (idx + 1) % questions.length;
        loadQuestion(idx);
        saveProgress();
      });

      // Build the wheel once
      buildCipherWheel();

      // Load saved progress on page load
      loadProgress();
      // Initial load
      loadQuestion(idx);
      }); // End DOMContentLoaded
    </script>

    <footer>
      CCST9077 | Members:
    </footer>

    <div id="settings-btn">⚙️</div>
    <div id="settings-menu">
      <div id="1option" class="option">Option 1</div>
      <div id="2option" class="option">Option 2</div>
    </div>
    <div id="info-container">
      <div id="info-icon">ℹ</div>
      <div id="info-popup">Hello! I'm a placeholder!</div>
    </div>
    <!-- Levels slide-out tab (restored) -->
    <div id="levels-tab" title="Open levels">Levels</div>
    <aside id="levels-sidebar" aria-hidden="true">
      <button id="levels-close" class="btn btn-outline">Close</button>
      <h3>Levels</h3>
      <ul class="levels-list">
        <li><a href="game.html">Level 1 — Caesar's Cipher</a></li>
        <li><a href="level2.html">Level 2 — Modern Crypto (MCQ)</a></li>
        <li><a href="level3_materials.html">Level 3 — QKD Materials</a></li>
      </ul>
    </aside>
  </body>
</html>

<script>
  const btn = document.getElementById("settings-btn");
  const menu = document.getElementById("settings-menu");
  const oneOption = document.getElementById("1option");
  const twoOption = document.getElementById("2option");

  let menuOpen = false;

  btn.onclick = () => {
    menuOpen = !menuOpen;
    menu.style.display = menuOpen ? "block" : "none";
  };
</script>
<script>
  // Levels sidebar toggle (shared behaviour)
  (function(){
    const tab = document.getElementById('levels-tab');
    const sidebar = document.getElementById('levels-sidebar');
    const closeBtn = document.getElementById('levels-close');
    if(tab && sidebar){
      tab.addEventListener('click', ()=>{ sidebar.classList.add('open'); sidebar.setAttribute('aria-hidden','false'); });
      closeBtn.addEventListener('click', ()=>{ sidebar.classList.remove('open'); sidebar.setAttribute('aria-hidden','true'); });
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ sidebar.classList.remove('open'); sidebar.setAttribute('aria-hidden','true'); } });
    }
  })();
</script>
