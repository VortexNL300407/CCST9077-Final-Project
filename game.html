<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quantum Cryptography - Game</title>
    <link rel="stylesheet" href="style.css" id="theme-stylesheet">
    <!-- Add minimal inline styles for the cipher wheel -->
    <style>
      /* Add background image styling */
      body {
        position: relative;
        background-image: url('media/game1.jpeg');
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
        background-repeat: no-repeat;
        overflow-x: hidden;
      }
      
      /* Add overlay to improve text readability */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 15, 30, 0.88);
        z-index: -1;
      }

      /* Cipher wheel */
      #cipher-wheel-container { margin-top: 1rem; padding: 1rem; border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; background: rgba(255,255,255,0.05); }
      .cipher-wheel-svg { width: 260px; height: 260px; }
      .cipher-wheel-svg text { font-family: system-ui, sans-serif; font-size: 14px; dominant-baseline: middle; text-anchor: middle; fill: #fff; }
      .cipher-wheel-svg circle { fill: none; stroke: rgba(255,255,255,0.25); }
      .cipher-wheel-meta { font-size: 0.9rem; opacity: 0.9; }

      /* Story-driven game UI */
      .game-story-header {
        background: rgba(20, 20, 50, 0.85);
        border: 2px solid rgba(255, 107, 157, 0.4);
        border-radius: 15px;
        padding: 1.5rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(255, 107, 157, 0.2);
        animation: fadeInUp 0.6s ease-out;
      }

      .eve-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: #ff6b9d;
        font-weight: bold;
        font-size: 1.1rem;
        margin-bottom: 1rem;
      }

      .eve-badge::before,
      .eve-badge::after {
        content: "üîç";
        font-size: 1.2rem;
      }

      .story-intro {
        color: #e0e0ff;
        line-height: 1.7;
        font-size: 1.05rem;
      }

      .story-intro strong {
        color: #ffd700;
      }

      .story-intro em {
        color: #00ffff;
        font-style: normal;
      }

      .mission-objective {
        background: rgba(255, 215, 0, 0.1);
        border-left: 4px solid #ffd700;
        padding: 0.8rem 1rem;
        margin-top: 1rem;
        border-radius: 6px;
        color: #ffd700;
        font-weight: 600;
      }

      .encrypted-message-box {
        background: linear-gradient(135deg, rgba(10, 15, 36, 0.8), rgba(30, 40, 80, 0.8));
        border: 2px solid rgba(0, 255, 255, 0.4);
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1.5rem 0;
        position: relative;
        overflow: hidden;
      }

      .encrypted-message-box::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, #00ffff, transparent);
        animation: scan 3s linear infinite;
      }

      @keyframes scan {
        0%, 100% { transform: translateX(-100%); }
        50% { transform: translateX(100%); }
      }

      .encrypted-label {
        color: #00ffff;
        font-size: 0.9rem;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 0.8rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .encrypted-label::before {
        content: "üîí";
      }

      .encrypted {
        font-family: 'Courier New', monospace;
        font-size: 1.8rem;
        color: #fff;
        text-align: center;
        letter-spacing: 4px;
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        padding: 1rem;
        background: rgba(0, 255, 255, 0.05);
        border-radius: 8px;
      }

      .cipher-section {
        background: rgba(30, 15, 50, 0.6);
        border: 2px solid rgba(100, 200, 255, 0.3);
        border-radius: 15px;
        padding: 1.5rem;
        margin: 1.5rem 0;
      }

      .section-title {
        color: #57acf6;
        font-size: 1.3rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .section-title::before {
        content: "‚öõÔ∏è";
        animation: rotate-slow 4s linear infinite;
      }

      #answer-area {
        background: rgba(20, 20, 50, 0.6);
        border: 2px solid rgba(255, 107, 157, 0.3);
        border-radius: 12px;
        padding: 1.5rem;
        margin-top: 1.5rem;
      }

      #answer-area label {
        color: #ff6b9d;
        font-weight: bold;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.8rem;
      }

      #answer-area label::before {
        content: "üí¨";
      }

      #answer {
        background: rgba(10, 15, 36, 0.8);
        border: 2px solid rgba(0, 255, 255, 0.4);
        color: #fff;
        font-family: 'Courier New', monospace;
        font-size: 1.2rem;
        padding: 1rem;
        border-radius: 8px;
        width: 50%;
        transition: all 0.3s ease;
      }

      #answer:focus {
        outline: none;
        border-color: #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }

      .button-group {
        display: flex;
        gap: 0.8rem;
        flex-wrap: wrap;
        margin-top: 1rem;
      }

      .hint-box {
        display: none;
        background: rgba(255, 179, 71, 0.15);
        border: 2px solid #ffb347;
        border-radius: 10px;
        padding: 1rem;
        margin-top: 1rem;
        animation: slideDown 0.3s ease-out;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .hint-box p {
        color: #ffb347;
        margin: 0;
        font-weight: 600;
      }

      #feedback {
        padding: 1rem;
        border-radius: 8px;
        font-size: 1.1rem;
        text-align: center;
        animation: popIn 0.4s cubic-bezier(.2,.9,.2,1);
      }

      #explanation {
        background: rgba(0, 255, 255, 0.1);
        border-left: 4px solid #00ffff;
        padding: 1rem;
        border-radius: 6px;
        animation: slideInRight 0.3s ease;
      }

      #score {
        background: linear-gradient(135deg, rgba(126, 242, 126, 0.2), rgba(87, 172, 246, 0.2));
        border: 2px solid rgba(126, 242, 126, 0.4);
        padding: 1rem;
        border-radius: 10px;
        text-align: center;
        font-size: 1.2rem;
        font-weight: bold;
        color: #7ef27e;
        text-shadow: 0 0 10px rgba(126, 242, 126, 0.5);
      }

      #cipher-wheel-container {
        background: rgba(10, 15, 36, 0.6);
        border: 2px solid rgba(87, 172, 246, 0.3);
        border-radius: 12px;
        padding: 1.5rem;
      }

      .wheel-controls {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .wheel-label {
        color: #57acf6;
        font-weight: bold;
        font-size: 1.1rem;
      }

      #wheel-shift {
        width: 100%;
        height: 8px;
        border-radius: 5px;
        background: rgba(87, 172, 246, 0.2);
        outline: none;
      }

      #wheel-shift::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(135deg, #00ffff, #57acf6);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      }

      #wheel-shift::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(135deg, #00ffff, #57acf6);
        cursor: pointer;
        border: none;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      }

      #wheel-shift-label {
        color: #00ffff;
        font-size: 1.5rem;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      }

      .confirm-dialog {
        display: none; /* Hide give up dialog */
      }

      .confirm-dialog p {
        color: #ff6b9d;
        font-weight: bold;
        margin: 0 0 1rem 0;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Quantum Cryptography</h1>
      <p><em>Cryptography of the future</em></p>
      <nav>
        <a href="index.html">Home</a>
        <a href="game.html">Game</a>
        <a href="materials.html">Materials</a>
      </nav>
    </header>

    <main class="page">
      <section class="card">
        <!-- Story Header -->
        <div class="game-story-header">
          <div class="eve-badge">EVE'S MISSION</div>
          <div class="story-intro">
            <p><strong>Bob's</strong> messages to <em>Alice</em> are protected with a Caesar cipher. I need to decode what they're talking about so I can find a way to interrupt their relationship.</p>
            <div class="mission-objective">
              üéØ Objective: Decode the encrypted messages. Hints are available if you get stuck.
            </div>
          </div>
        </div>

        <h2 style="color: #57acf6; text-align: center; margin-bottom: 2rem;">Level 1 ‚Äî Caesar's Cipher</h2>

        <div id="level1">
          <!-- Cipher Wheel Section (now first) -->
          <div class="cipher-section">
            <div class="section-title">Caesar Cipher</div>
            <div id="cipher-wheel-container" aria-label="Caesar cipher wheel">
              <div style="display:flex; align-items:center; gap:1.5rem; flex-wrap:wrap; justify-content: center;">
                <svg id="cipher-wheel-svg" class="cipher-wheel-svg" viewBox="0 0 260 260" width="260" height="260" role="img" aria-label="Cipher wheel"></svg>
                <div class="wheel-controls">
                  <div class="wheel-label">Cipher Wheel Shift</div>
                  <div class="cipher-wheel-meta" style="margin-bottom:0.6rem;">Rotate to align plaintext with ciphertext</div>
                  <label for="wheel-shift" style="color: #57acf6; font-weight: bold;">
                    Shift: <span id="wheel-shift-label">0</span>
                  </label>
                  <input id="wheel-shift" type="range" min="-25" max="25" step="1" value="0">
                </div>
              </div>
            </div>
          </div>

          <!-- Encrypted Message Display (now second) -->
          <div class="encrypted-message-box">
            <div class="encrypted-label">Intercepted Message</div>
            <div id="encrypted" class="encrypted">--</div>
            <div id="hintline" class="hint-box">
              <p>üí° <span id="hint-text"></span></p>
            </div>
          </div>

          <!-- Answer Area -->
          <div id="answer-area">
            <label for="answer">Your Decoded Answer</label>
            <input id="answer" type="text" placeholder="Type the decoded message here..." />
            <div class="button-group">
              <button id="hint" class="btn btn-outline">üí° Show Hint</button>
              <button id="prev-btn" class="btn btn-outline">‚¨ÖÔ∏è Previous Question</button>
              <button id="submit" class="btn btn-primary">‚úì Submit Answer</button>
              <button id="level2-btn" class="btn btn-primary" style="display:none;">üéØ Proceed to Level 2</button>
                </div>
              </div>

              <div id="feedback" style="margin-top:1rem; font-weight:700;"></div>
              <div id="explanation" style="margin-top:0.6rem; display:none;"></div>
          
          <!-- Remove confirmation dialog for Give up -->

          <!-- Remove score display -->
        </div>

        <p style="margin-top:2rem; text-align: center;"><a class="btn btn-outline" href="index.html">‚¨ÖÔ∏è Return Home</a></p>
      </section>
    </main>

    <script>
      /*
        Edit the `questions` array below to change Level 1 content.
        Each entry: { encrypted: string, answer: string, hint: string (optional), explanation: string (optional) }
      */
      const questions = [
        { encrypted: 'RVBOUVN', hint: 'Shift: -1', answer: 'QUANTUM', explanation: "Bob is interested in quantum information. I need to learn more about it." },
        { encrypted: 'GH ZKHBD', hint: 'Shift: +1', answer: 'HI ALICE', explanation: "They are always chatting. I'm jealous." },
        { encrypted: 'P SVCL FVB', hint: 'This is the last question! Try to answer yourself, if you love Bob!', answer: 'I LOVE YOU', explanation: "Oh no! Bob loves Alice. I want to steal Bob from Alice." },
      ];

      // Simple utilities for normalising answers for comparison
      function normalise(s){
        return s.toUpperCase().replace(/[^A-Z0-9 ]+/g,'').replace(/\s+/g,' ').trim();
      }

      // Wait for DOM to be ready
      document.addEventListener('DOMContentLoaded', function() {
        // UI elements
        const encryptedEl = document.getElementById('encrypted');
        const hintLine = document.getElementById('hintline');
        const answerInput = document.getElementById('answer');
        const submitBtn = document.getElementById('submit');
        const hintBtn = document.getElementById('hint');
        const level2Btn = document.getElementById('level2-btn');
        const confirmGiveupDiv = document.getElementById('confirm-giveup');
        const confirmYesBtn = document.getElementById('confirm-yes');
        const confirmNoBtn = document.getElementById('confirm-no');
        const feedback = document.getElementById('feedback');
        const explanation = document.getElementById('explanation');
        const prevBtn = document.getElementById('prev-btn');

        // Cipher wheel elements
        const wheelSvg = document.getElementById('cipher-wheel-svg');
        const wheelShiftInput = document.getElementById('wheel-shift');
        const wheelShiftLabel = document.getElementById('wheel-shift-label');
        const SVG_NS = 'http://www.w3.org/2000/svg';
        let wheelOuterGroup = null;
        let wheelInnerGroup = null;
        const cx = 130, cy = 130, rInner = 80, rOuter = 110, stepDeg = 360 / 26;

        // Track current rotation angle to animate between states
        let currentOuterAngle = 0;
        let animFrame = null;

        function createSVGEl(name, attrs = {}) {
          const el = document.createElementNS(SVG_NS, name);
          for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
          return el;
        }

        function buildCipherWheel() {
          if (!wheelSvg) return;
          wheelSvg.innerHTML = '';

          // Background rings
          wheelSvg.appendChild(createSVGEl('circle', { cx, cy, r: rOuter + 8 }));
          wheelSvg.appendChild(createSVGEl('circle', { cx, cy, r: rInner - 8 }));

          wheelInnerGroup = createSVGEl('g', { class: 'inner-ring' });
          wheelOuterGroup = createSVGEl('g', { class: 'outer-ring' });

          for (let i = 0; i < 26; i++) {
            const letter = String.fromCharCode(65 + i);
            const angle = (i / 26) * 2 * Math.PI - Math.PI / 2;

            const xi = cx + rInner * Math.cos(angle);
            const yi = cy + rInner * Math.sin(angle);
            const xo = cx + rOuter * Math.cos(angle);
            const yo = cy + rOuter * Math.sin(angle);

            const tInner = createSVGEl('text', { x: xi, y: yi });
            tInner.textContent = letter;
            const tOuter = createSVGEl('text', { x: xo, y: yo });
            tOuter.textContent = letter;

            wheelInnerGroup.appendChild(tInner);
            wheelOuterGroup.appendChild(tOuter);
          }

          wheelSvg.appendChild(wheelInnerGroup);
          wheelSvg.appendChild(wheelOuterGroup);
          // Ensure starting transform is centered
          currentOuterAngle = 0;
          wheelOuterGroup.setAttribute('transform', `rotate(${currentOuterAngle} ${cx} ${cy})`);
        }

        function setWheelShift(s, animate = true) {
          if (!wheelOuterGroup) return;
          const targetAngle = s * stepDeg;
          wheelShiftLabel.textContent = s >= 0 ? `+${s}` : `${s}`;

          if (!animate) {
            if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
            currentOuterAngle = targetAngle;
            wheelOuterGroup.setAttribute('transform', `rotate(${currentOuterAngle} ${cx} ${cy})`);
            return;
          }

          // Smooth animation via rAF
          const startAngle = currentOuterAngle;
          const delta = targetAngle - startAngle;
          const duration = 400; // ms
          const startTime = performance.now();

          if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }

          function step(t) {
            const k = Math.min(1, (t - startTime) / duration);
            const eased = 1 - Math.pow(1 - k, 3); // easeOutCubic
            const angle = startAngle + delta * eased;
            wheelOuterGroup.setAttribute('transform', `rotate(${angle} ${cx} ${cy})`);
            if (k < 1) animFrame = requestAnimationFrame(step);
            else { currentOuterAngle = targetAngle; animFrame = null; }
          }
          animFrame = requestAnimationFrame(step);
        }

        function parseHintShift(hint) {
          if (typeof hint !== 'string' || hint.trim() === '') return null;
          const val = parseInt(hint, 10);
          return Number.isFinite(val) ? Math.max(-25, Math.min(25, val)) : null;
        }

        function updateWheelForQuestion() {
          const q = questions[idx];
          const s = parseHintShift(q.hint);
          if (s !== null) {
            wheelShiftInput.value = s;
            setWheelShift(s, true);
          } else {
            wheelShiftInput.value = 0;
            setWheelShift(0, false);
          }
        }

        wheelShiftInput.addEventListener('input', () => {
          const s = parseInt(wheelShiftInput.value, 10) || 0;
          setWheelShift(s, true);
        });

        let idx = 0; let answered = false;
        let completedQuestions = new Set(); // Track which questions have been completed

        // Save progress to localStorage
        function saveProgress() {
          const progress = {
            idx: idx,
            answered: answered,
            completedQuestions: Array.from(completedQuestions)
          };
          localStorage.setItem('level1Progress', JSON.stringify(progress));
        }

        // Load progress from localStorage
        function loadProgress() {
          const saved = localStorage.getItem('level1Progress');
          if(saved) {
            const progress = JSON.parse(saved);
            idx = progress.idx;
            answered = progress.answered;
            completedQuestions = new Set(progress.completedQuestions || []);
          }
        }

        // Wire Previous Question button
        if(prevBtn) {
          prevBtn.addEventListener('click', ()=>{
            if(typeof idx !== 'number' || !Array.isArray(questions) || questions.length === 0) return;
            idx = (idx - 1 + questions.length) % questions.length;
            loadQuestion(idx);
            saveProgress();
          });
        }

        // Wire give-up confirm (no review history)
        if(confirmYesBtn) {
          confirmYesBtn.addEventListener('click', ()=>{
            completedQuestions.add(idx);
            answered = true;
            submitBtn.disabled = true;
            // Advance to next question
            idx = (idx + 1) % questions.length;
            loadQuestion(idx);
            saveProgress();
            if(confirmGiveupDiv) confirmGiveupDiv.style.display = 'none';
          });
        }

      function loadQuestion(i){
        const q = questions[i];
        encryptedEl.textContent = q.encrypted;
        const hintText = document.getElementById('hint-text');
        if (hintText) {
          hintText.textContent = q.hint ? `${q.hint}` : '';
        }
        hintLine.style.display = 'none';
        answerInput.value = '';
        feedback.textContent = '';
        feedback.style.background = 'transparent';
        feedback.style.border = 'none';
        feedback.style.display = 'none';
        explanation.textContent = '';
        explanation.style.display = 'none';
        level2Btn.style.display = 'none';
        submitBtn.disabled = false;
        answered = false;
        answerInput.focus();
        // Update wheel for this question (animate if hint present)
        updateWheelForQuestion();
        // Hide Previous button on the very first question
        if(prevBtn) prevBtn.style.display = (i === 0) ? 'none' : '';
        
        // Show Level 2 button only when on the last question and all questions completed
        if (i === questions.length - 1 && completedQuestions.size === questions.length) {
          level2Btn.style.display = '';
        } else {
          level2Btn.style.display = 'none';
        }
      }

      function checkAnswer(){
        if(answered) return;
        const user = normalise(answerInput.value);
        
        // Don't deduct marks for empty answers
        if(user === '') {
          feedback.style.background = 'rgba(255, 179, 71, 0.2)';
          feedback.style.border = '2px solid #ffb347';
          feedback.style.color = '#ffb347';
          feedback.textContent = '‚ö†Ô∏è Please enter an answer before submitting.';
          feedback.style.display = 'block';
          return;
        }
        
        const expected = normalise(questions[idx].answer);
        if(user === expected){
          feedback.style.display = 'block';
          feedback.style.background = 'rgba(126, 242, 126, 0.2)';
          feedback.style.border = '2px solid #7ef27e';
          feedback.style.color = '#7ef27e';
          feedback.textContent = '‚úì Correct! Great work, Eve!';
          completedQuestions.add(idx); // Mark this question as completed
          explanation.textContent = questions[idx].explanation || '';
          explanation.style.display = 'block';
          answered = true;
          submitBtn.disabled = true;
          
          // After correct answer: advance to next question if not at the last index.
          // If at last index, try to go to the next unanswered question; if all answered show Level 2.
          const lastIndex = questions.length - 1;
          function findNextUnanswered(from) {
            for(let i = 1; i <= questions.length; i++){
              const cand = (from + i) % questions.length;
              if(!completedQuestions.has(cand)) return cand;
            }
            return -1;
          }

          if(idx < lastIndex){
            // advance sequentially
            setTimeout(() => {
              idx = idx + 1;
              loadQuestion(idx);
              saveProgress();
            }, 2000);
          } else {
            // we're at the last question
            const nextUnanswered = findNextUnanswered(idx);
            if(nextUnanswered === -1){
              // all done
              level2Btn.style.display = '';
              feedback.textContent = '‚úì Excellent! You\'ve decrypted all messages! Proceed to Level 2.';
            } else {
              // jump to next unanswered question
              setTimeout(() => {
                idx = nextUnanswered;
                loadQuestion(idx);
                saveProgress();
              }, 2000);
            }
          }
        } else {
          feedback.style.display = 'block';
          feedback.style.background = 'rgba(255, 154, 154, 0.2)';
          feedback.style.border = '2px solid #ff9a9a';
          feedback.style.color = '#ff9a9a';
          feedback.textContent = '‚ùå Decryption Failed. Try again! If you really love Bob.';
        }
        saveProgress();
      }

      submitBtn.addEventListener('click', checkAnswer);
      answerInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') checkAnswer(); });

      hintBtn.addEventListener('click', ()=>{
        const q = questions[idx];
        hintLine.style.display = hintLine.style.display === 'none' ? 'block' : 'none';
      });

      level2Btn.addEventListener('click', ()=>{
        window.location.href = 'level2.html';
      });

      // Build the wheel once
      buildCipherWheel();

      // Load saved progress on page load
      loadProgress();
      // Initial load
      loadQuestion(idx);
      }); // End DOMContentLoaded
    </script>

    <footer>
      CCST9077 | Members:
    </footer>
    <div id="info-container">
      <div id="info-icon">‚Ñπ</div>
      <div id="info-popup">This project is an informative and educational website designed to make information on quantum cryptography accessible to a wider audience.</div>
    </div>
    <div id="settings-btn">‚öôÔ∏è</div>
    <div id="settings-menu">
      <div id="mute-option" class="option">Mute Music</div>
      <div id="theme-option" class="option">üîÑ Larger Fonts (Accessibility)</div>
    </div>
    <!-- Levels slide-out tab (restored) -->
    <div id="levels-tab" title="Open levels">Levels</div>
    <aside id="levels-sidebar" aria-hidden="true">
      <button id="levels-close" class="btn btn-outline">Close</button>
      <h3>Levels</h3>
      <ul class="levels-list">
        <li><a href="game.html">Level 1 ‚Äî Caesar's Cipher</a></li>
        <li><a href="level2.html">Level 2 ‚Äî Modern Crypto (MCQ)</a></li>
        <li><a href="level3_materials.html">Level 3 ‚Äî QKD Materials</a></li>
      </ul>
    </aside>

    <!-- PARALLAX EFFECT SCRIPT -->
  <script>
    (function(){
      const body = document.body;
      if(!body) return;
      
      let ticking = false;
      const parallaxSpeed = -0.05;
      
      // Calculate initial offset to prevent jump
      const initialScroll = window.pageYOffset;
      const initialOffset = initialScroll * parallaxSpeed;
      
      function updateParallax() {
        const scrolled = window.pageYOffset;
        const offset = scrolled * parallaxSpeed;
        
        // Apply offset relative to initial position
        body.style.backgroundPositionY = `calc(50% + ${offset}px)`;
        
        ticking = false;
      }
      
      function requestTick() {
        if (!ticking) {
          window.requestAnimationFrame(updateParallax);
          ticking = true;
        }
      }
      
      // Set initial position
      body.style.backgroundPositionY = `calc(50% + ${initialOffset}px)`;
      
      window.addEventListener('scroll', requestTick, { passive: true });
    })();
  </script>
  <!-- END PARALLAX EFFECT SCRIPT -->

  <!-- Audio element for background music -->
  <audio id="bgm" loop>
    <source src="media/bgm.mp3" type="audio/mpeg">
  </audio>

  <!-- BACKGROUND MUSIC SYSTEM -->
  <script>
    (function(){
      const bgm = document.getElementById('bgm');
      if(!bgm) return;
      const btn = document.getElementById('settings-btn');
      const menu = document.getElementById('settings-menu');
      const muteOption = document.getElementById('mute-option');
      let menuOpen = false;

      let savedMuted = localStorage.getItem('musicMuted') === 'true';
      let savedTime = parseFloat(localStorage.getItem('musicTime')) || 0;
      bgm.muted = savedMuted;
      bgm.currentTime = savedTime;

      window.addEventListener('click', ()=>{ bgm.play().catch(()=>{}); bgm.volume = 0.2; }, { once: true });
      bgm.volume = 0.2; bgm.play().catch(()=>{});

      setInterval(()=>{ localStorage.setItem('musicTime', bgm.currentTime); }, 1000);

      btn.onclick = ()=>{ menuOpen = !menuOpen; menu.style.display = menuOpen ? 'block' : 'none'; };
      muteOption.onclick = ()=>{ bgm.muted = !bgm.muted; localStorage.setItem('musicMuted', bgm.muted); muteOption.textContent = bgm.muted ? 'Unmute Music' : 'Mute Music'; };
      muteOption.textContent = bgm.muted ? 'Unmute Music' : 'Mute Music';
    })();
  </script>
  <!-- END BACKGROUND MUSIC SYSTEM -->

  <!-- LEVELS SIDEBAR TOGGLE SYSTEM -->
  <script>
    (function(){
      const tab = document.getElementById('levels-tab');
      const sidebar = document.getElementById('levels-sidebar');
      const closeBtn = document.getElementById('levels-close');
      if(tab && sidebar){
        tab.addEventListener('click', ()=>{ sidebar.classList.add('open'); sidebar.setAttribute('aria-hidden','false'); });
        closeBtn.addEventListener('click', ()=>{ sidebar.classList.remove('open'); sidebar.setAttribute('aria-hidden','true'); });
        document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ sidebar.classList.remove('open'); sidebar.setAttribute('aria-hidden','true'); } });
      }
    })();
  </script>
  <!-- END LEVELS SIDEBAR TOGGLE SYSTEM -->

  <!-- THEME SWITCHER SCRIPT -->
  <script>
    (function(){
      const themeOption = document.getElementById('theme-option');
      const themeSheet = document.getElementById('theme-stylesheet');
      if(!themeOption || !themeSheet) return;

      let useAccessibleTheme = localStorage.getItem('useAccessibleTheme') === 'true';
      
      function applyTheme(accessible) {
        if(accessible) {
          themeSheet.href = 'styl2.css';
          themeOption.textContent = 'üîÑ Standard Fonts';
          localStorage.setItem('useAccessibleTheme', 'true');
        } else {
          themeSheet.href = 'style.css';
          themeOption.textContent = 'üîÑ Larger Fonts (Accessibility)';
          localStorage.setItem('useAccessibleTheme', 'false');
        }
      }

      applyTheme(useAccessibleTheme);

      themeOption.addEventListener('click', ()=>{
        useAccessibleTheme = !useAccessibleTheme;
        applyTheme(useAccessibleTheme);
      });
    })();
  </script>
  <!-- END THEME SWITCHER SCRIPT -->
</html>
